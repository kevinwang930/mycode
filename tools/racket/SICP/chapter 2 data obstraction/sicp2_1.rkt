#lang racket
(require "basic_function.rkt")
;chapter 2 building abstractions with data
; introduction to data abstractions
;data abstraction of rational numbers
(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))
(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))
(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))
;using pairs primitive procedure cons (construct)
; car (content of addressed part of register)
; cdr (content of decrement part of register) in IMB MACHINE
;procedure implementation of cons car cdr
#|(define (cons x y)
  (define (dispatch m)
    (cond ((= m 0) x)
          ((= m 1) y)
          (else (error "Augument not 0 or 1: cons" m))))
  dispatch)
(define (car z) (z 0))
(define (cdr z) (z 1)) |#

;another procedural implementation of cons car cdr
#;(define (cons x y)
  (lambda (m)
    (m x y)))

#;(define (car z)
  (z (lambda (p q) p)))
#;(define (cdr z)
  (z (lambda (p q) q)))

(define (make-rat n d)
  (cond
    ((or (and (negative? n) (negative? d))
         (and (positive? n) (negative? d)))
     (make-rat-gcd (- n) (- d)))
    (else (make-rat-gcd n d))))
(define (make-rat-gcd n d)    
  (let ((gc (gcd n d)))
    (if (= gc 1)
        (cons n d)
        (cons (/ n gc) (/ d gc)))))

(define (numer r) (car r))
(define (denom r) (cdr r))
(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))
; data abstraction of line segment in plane
(define (make-point x y)
  (cons x y))
(define (x-point p)
  (car p))
(define (y-point p)
  (cdr p))
(define (print-point p)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
(define (make-segment p1 p2)
  (cons p1 p2))
(define (start-segment s)
  (car s))
(define (end-segment s)
  (cdr s))
(define (midpoint-segment s)
  (make-point (average (x-point (start-segment s))
                       (x-point (end-segment s)))
              (average (y-point (start-segment s))
                       (y-point (end-segment s)))))
(define (length-segment s)
  (sqrt (+ (square (- (x-point (start-segment s))
                      (x-point (end-segment s))))
           (square (- (y-point (start-segment s))
                      (y-point (end-segment s)))))))
(define p1 (make-point 1 2))
(define p2 (make-point 1 5))
(define p3 (make-point 7 2))
(define s1 (make-segment p1 p2))
(define mp (midpoint-segment s1))
;data abstraction of rectangle

;consturctor and selector
(define (make-rectangle l-start-point l-end-point w-end-point)
  (cons l-start-point (cons l-end-point w-end-point)))
(define (l-segment-rectangle r)
  (make-segment (car r) (car (cdr r))))
(define (w-segment-rectangle r)
  (make-segment (car (cdr r)) (cdr (cdr r))))


(define (length-rectangle r)
  (length-segment (l-segment-rectangle r)))
(define (width-rectangle r)
  (length-segment (w-segment-rectangle r)))
(define (perimeter-rectangle r)
  (* (+ (length-rectangle r)
        (width-rectangle r))
     2))
(define (area-rectangle r)
  (* (length-rectangle r)
     (width-rectangle r)))
(define (arith-cons a b)
  (* (expt 2 a)
     (expt 3 b)))

(define (nth-quotient z a)
  (if (= (remainder z a) 0)
      (+ 1 (nth-quotient (/ z a) a))
      0
      ))
(define (arith-car z)
  (nth-quotient z 2))
(define (arith-cdr z)
  (nth-quotient z 3))

;procedural representation of numbers
(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
(define one
  (lambda (f) (lambda (x) (f x))))
(define two
  (lambda (f) (lambda (x) (f (f x)))))
#;(define (+ a b)
  (lambda (f)
    (lambda (x)
      ((a f) ((b f) x)))))

;procedural representation of interval
(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))
(define (mul-interval x y)
  (let ((LX (lower-bound x))
        (LY (lower-bound y))
        (UY (upper-bound y))
        (UX (upper-bound x)))
    (cond
      ((and (>= LX 0) (>= LY 0))
       (make-interval (* LX LY) (* UX UY)))
      ((and (<= UX 0) (<= UY 0))
       (make-interval (* UX UY) (* LX LY)))
      ((and (>= LX 0) (<= UY 0))
       (make-interval (* UX LY) (* LX UY)))
      ((and (>= LY 0) (<= UX 0))
       (make-interval (* UY LX) (* LY UX)))
      ;interval x spans zero
      ((and (< LX 0) (> UX 0) (<= UY 0))
       (make-interval (* UX LY) (* LX LY)))
      ((and (< LX 0) (> UX 0) (>= LY 0))
       (make-interval (* LX UY) (* UX UY)))
      ; y spans zero
      ((and (< LY 0) (> UY 0) (<= UX 0))
       (make-interval (* UY LX) (* LX LY)))
      ((and (< LY 0) (> UY 0) (>= LX 0))
       (make-interval (* LY UX) (* UX UY)))
      
      ;2 intervals spans zero
      ((and (< LY 0) (> UY 0) (< LX 0) (> UX 0))
       (let ((L1 (* LX UY))
             (L2 (* UX LY))
             (U1 (* LX LY))
             (U2 (* UX UY)))
         (make-interval (min L1 L2)
                        (max U1 U2)))))))
(define (div-interval x y)
  (let ((L (lower-bound y))
        (U (upper-bound y)))
    (if (and (<= L 0) (>= U 0))
        (error "interval spans zero" y)
        (mul-interval x
                  (make-interval (/ 1.0 U)
                                 (/ 1.0 L))))))
(define (make-interval a b)
  (cons a b))
(define (upper-bound x)
  (cdr x))
(define (lower-bound x)
  (car x))
(define (sub-interval x y)
  (make-interval (- (lower-bound x) (upper-bound y))
                 (- (upper-bound x) (lower-bound y))))

(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))
(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))
(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))

(define (make-center-point c p)
  (make-interval (- c (* p c)) (+ c (* p c))))
(define (tolerance-percent i)
  (/ (width i) (center i)))

(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))

(define (par2 r1 r2)
  (let ((one (make-interval 1 1)))
    (div-interval one
                (add-interval (div-interval one r1)
                              (div-interval one r2)))))






;test


#;(for-each (lambda (x)
            (display x)
            (newline))
          list1)
;(fringe list1)
;(count-leaves list1)
;(map inc list1)
;(scale-list list1 2)
;(square-list-1 list1)
;(same-parity 2 3 4 5 6 7)
;(count-change 100 us-coins)
;(last-pair squares)
;(reverse squares)
;(length squares)
;(append odds squares)
(define i1 (make-interval 1 2))
(define i2 (make-interval -4 2))
(define i3 (make-center-point 10 0.1))
(define i4 (make-center-point 10 0.1))

(define ic (par1 i3 i4))
;ic
;(center ic)
;(tolerance-percent ic)
;(define ic1 (par2 i3 i4))
;ic1
;(center ic1)
;(tolerance-percent ic1)
;(mul-interval i1 (mul-interval i2 i3))
;(mul-interval i3 (mul-interval i2 i1))
;(mul-interval i1 i2)
;(tolerance-percent i2)
;(tolerance-percent i1)
;(((+ one two) inc) 0)
;(define z (arith-cons 3 4))
;(arith-car z)
;(arith-cdr z)
;(define r1 (make-rectangle p3 p1  p2))
;(define l (l-segment-rectangle r1))
;(define w (w-segment-rectangle r1))
;(length-rectangle r1)
;(width-rectangle r1)
;(perimeter-rectangle r1)
;(area-rectangle r1)

;(print-point mp)
;(print-rat (make-rat -1 -2))
;(print-rat (make-rat 1 -3))
;(print-rat (make-rat 4 2))
;(print-rat (add-rat (make-rat -1 2) (make-rat 2 3)))

