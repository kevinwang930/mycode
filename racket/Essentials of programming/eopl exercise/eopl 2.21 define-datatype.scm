;;; define-datatype.scm

(define define-datatype:time-stamp "Time-stamp: <99/09/15 09:50:45 wand>")

(define define-datatype:version 
  (let ((date (substring define-datatype:time-stamp 13 21))
        (version "J")
        (release "2"))
    (string-append version "." release " " date)))

(printf "define-datatype.scm version ~a~%" define-datatype:version)

;;; Time-stamp: <99/02/01 11:44:43 wand>
;;; (time-stamp generated by emacs:  Type M-x time-stamp anywhere to update)

;;; This is an r5rs-compliant datatype system,

;;; A consequence of this design is that if someone decides to have a
;;; variant named `else', they cannot use it in the last clause of
;;; cases.  Another consequence is that lexically binding the
;;; identifier `else', a la (lambda (else) (cases ... (else ...))),
;;; causes else-clauses to break, so don't do that.

;;; (test-c) for chez and (test-m) for mzscheme is all that is needed
;;; to test either system.
;;; ------------------------------
;;; compatability

;;; Representation of raw data:
;;; variant-registry: '[[variant-name . type-name] ...]
;;; type-registry: '[type-name ...]
;;; type-name is '[variant-names . [[variant-name field-name ...] ...]]
;;; variant-name is a procedure for constructing the variant.
;;; All error messages are as they should be, except for when a
;;; datatype expression is given a non-symbol aa a type or
;;; any constructor is a non-symbol.  This is because define has
;;; its own error message in that case.  We could, of course, solve
;;; these problems with (eval '---).
;;; We will need a new chez? test at sometime in the future.
; (define chez?
;   (lambda ()
;     (equal? "#0()"
;       (let ((op (open-output-string)))
; 	(write '#() op)
; 	(get-output-string op)))))
(define chez? (lambda () #f))

(require (lib "pretty.ss"))

(define define-datatype:reset-registries 'ignored)
(define define-datatype:is-a-type? 'ignored)
(define define-datatype:datatype-checker&registry-updater 'ignored)
(define define-datatype:case-checker 'ignored)

(let ((define-datatype:type-registry '())
      (define-datatype:variant-registry '()))  

  (set! define-datatype:reset-registries
    (lambda ()
      (set! define-datatype:type-registry '())
      (set! define-datatype:variant-registry '())))

  (set! define-datatype:is-a-type?
    (lambda (type-name)
      (memq type-name define-datatype:type-registry)))

  (set! define-datatype:datatype-checker&registry-updater
    (letrec ((set?
	       (lambda (s)
		 (if (null? s) #t
		   (and (not (memq (car s) (cdr s))) (set? (cdr s)))))))
      (lambda (Type-name Variants)
	(if (not (symbol? Type-name))
	  (error 'define-datatype
	    "~nThe data type name ~s is not an identifier."
	    Type-name))
	(for-each
	  (lambda (variant)
	    (if (not (symbol? (car variant)))
	      (error 'define-datatype
		(string-append
		  "(While defining the ~a datatype)~n"
		  "  The variant-name ~s is not an identifier.")
		Type-name (car variant))))
	  Variants)
	(let ((variant-names (map car Variants)))
	  (if (not (set? variant-names))
	    (error 'define-datatype
	      (string-append
		"(While defining the ~a datatype)~n"
		"  Some of the variant-names are repeated: ~s.")
	      Type-name variant-names))
	  (for-each
	    (lambda (v)
	      (cond  ;;; This assq cannot be changed.
		((assq v define-datatype:variant-registry) =>
		 (lambda (pair)
		   (if (not (eq? (cdr pair) Type-name))
		     (error 'define-datatype
		       (string-append
			 "(While defining the ~a data type)~n"
			 "  The variant-name ~s has already been~n"
			 "  used as a variant name in ~s.")
		       Type-name v (cdr pair)))))))
	    variant-names)
	  (cond ;;; This assq could be a memq over variant names, only.
	        ;;; but would reqire a third local registry.
	    ((assq Type-name define-datatype:variant-registry) =>
	     (lambda (pair)
	       (error 'define-datatype
		 (string-append
		   "(While defining the ~a data type)~n"
		   "  The type name ~s has already been~n"
		   "  used as a variant name ~s in the~n"
		   "  data type ~s.")
		 Type-name Type-name (car pair) (cdr pair))))
	    ((memq Type-name variant-names)
	     (error 'define-datatype
	       (string-append
		 "(While defining the ~a data type)~n"
		 "  Variant name is the same as the data type name.")
	       Type-name)))
	  (for-each
	    (lambda (variant-name)
	      (cond
		((memq variant-name define-datatype:type-registry)
		 (error 'define-datatype
		   (string-append
		     "(While defining the ~a data type)~n"
		     "  The variant name ~s has already been~n"
		     "  used as a type name.")
		   Type-name variant-name))))
	    variant-names)
	  (set! define-datatype:variant-registry
	    (append
	      (map (lambda (v) (cons v Type-name)) variant-names)
	      define-datatype:variant-registry))
	  (cond 
	    ((memq Type-name define-datatype:type-registry) =>
	     (lambda (pair)
	       (set-car! pair Type-name)))
	    (else
	      (set! define-datatype:type-registry
		(cons Type-name define-datatype:type-registry))))))))
  
  (set! define-datatype:case-checker
    (let ((remq-or-false
	    (lambda (sym ls)
	      (call/cc
		(lambda (k)
		  (let f ((ls ls))
		    (cond ((null? ls) (k #f))
		      ((eq? (car ls) sym) (cdr ls))
		      (else (cons (car ls) (f (cdr ls)))))))))))
      (lambda (Type-value Type-name Expression clauses)
	(if (eq? Type-name Expression)
	  (begin
	    (pretty-print
	      (cons 'cases
		(cons Type-name
		  (cons Expression clauses))))
	    (error 'cases
	      (string-append
		"The data type ~s should not be the same~n"
		"  as a lexical variable.")
	      Type-name))
	  (let ((variant-table (cdr Type-value)))
	    (let f ((clauses* clauses)
		    (unused-variants (map car variant-table)))
	      (if (null? clauses*)
		(if (not (null? unused-variants))
		  (begin
		    (pretty-print
		      (cons 'cases
			(cons Type-name
			  (cons Expression clauses*))))
		    (error 'cases "Missing variant clauses for ~s."
		      unused-variants)))
		(let* ((head-clause (car clauses*))
		       (tail-clauses (cdr clauses*))
		       (purported-variant (car head-clause)))
		  (if (eq? purported-variant Expression)
		    (begin
		      (pretty-print
			(cons 'cases
			  (cons Type-name
			    (cons Expression clauses))))
		      (error 'cases
			(string-append
			  "The variant name ~s should not be the same~n"
			  "  as a lexical variable.")
			Expression))
		    (cond
		      ((and (null? tail-clauses) (eq? purported-variant 'else))
		 ; do nothing, we're fine
		       )			
		      ((assq purported-variant variant-table)
		       =>
		       (lambda (p)
			 (let ((fields (cdr p))
			       (purported-fields (cadr head-clause))
			       (new-unused-variants-or-false
				 (remq-or-false
				   purported-variant
				   unused-variants)))
			   (if (not (=
				      (length fields)
				      (length purported-fields)))
			     (begin
			       (pretty-print
				 (cons 'cases
				   (cons Type-name
				     (cons Expression clauses))))
			       (error 'cases "Bad fields in ~s." head-clause)))
			   (if (not new-unused-variants-or-false)
			     (begin
			       (pretty-print
				 (cons 'cases
				   (cons Type-name
				     (cons Expression clauses))))
			       (error 'cases "Duplicate variant clause: ~s."
				 head-clause)))
			   (f tail-clauses new-unused-variants-or-false))))
		      (else
			(pretty-print
			  (cons 'cases
			    (cons Type-name
			      (cons Expression clauses))))
			(error 'cases
			  "Bad clause: ~s."
			  head-clause)))))))))))))

;;; ------------------------------

;;;(define-datatype name
;;;  (variant-name (field-name predicate-exp) ...)
;;;  ...)
;;; * variant-names become constructors
;;; * The field-names are used only for debugging.

(define-syntax isa
  (syntax-rules ()
    ((_)
     (error 'isa "isa expects 1 argument, not 0."))
    ((_ type-name)
     (if (symbol? 'type-name)
       (lambda args
	 (if (null? args)
	   (error 'isa "(isa ~s) expects 1 argument, not 0." 'type-name)
	   (if (null? (cdr args))
	     (let ((variant (car args)))
	       (let ((type-info type-name)) 
		 (if (and (pair? type-info) (list? (car type-info)))
		   (and (pair? variant)
		     (memq (car variant) (car type-info)) #t)
		   (error 'isa
		     (string-append
		       "(isa ~s) did not get a data type bound to an~n"
		       "  appropriate structure: ~s.~n"
		       "  This tends to happen when the type name is~n"
		       "  bound to a lexical variable.")
		     'type-name type-info))))
	     (error 'isa
	       (string-append
		 "(isa ~s) expects 1 argument, not ~s.~n"
		 "  With argument list = ~s.")
	       'type-name (length args) args))))
       (error 'isa "Type name is not a symbol: ~s." 'type-name)))
    ((_  type-name other ...)
     (error 'isa "(isa ~s) expects 1 argument, not ~s with ~s."
       'type-name (add1 (length '(other ...)))
       (cons 'isa '(type-name other ...))))))

(define-syntax define-datatype
  (syntax-rules ()
    [(_ Type-name)
     (error 'define-datatype
       (string-append
	 "~n  There are no variants: ~n  ~s.")
       '(define-datatype Type-name))]
    [(_ Type-name Type-name?
       (Variant-name (Field-name Pred?) ...)
       ...)
     (begin
       (define-datatype:datatype-checker&registry-updater
	 'Type-name 
	 '((Variant-name (Field-name Pred?) ...)
	   ...))
       (define Type-name
	 (cons '(Variant-name ...)
	   '((Variant-name Field-name ...) ...)))
       (define Type-name?
	 (if (symbol? 'Type-name)
	   (lambda args
	     (if (null? args)
	       (error 'Type-name? "expects 1 argument, not 0.")
	       (if (null? (cdr args))
		 (let ((variant (car args)))
		   (let ((type-info Type-name)) 
		     (if (and (pair? type-info) (list? (car type-info)))
		       (and (pair? variant)
			 (memq (car variant) (car type-info)) #t)
		       (error 'Type-name?
			 (string-append
			   "did not get a data type bound to an~n"
			   "  appropriate structure: ~s.~n"
			   "  This tends to happen when the type name is~n"
			   "  bound to a lexical variable.")
			 'type-name type-info))))
		 (error 'Type-name?
		   (string-append
		     "expects 1 argument, not ~s.~n"
		     "  With argument list = ~s.")
		    (length args) args))))
	   (error 'Type-name "Type name is not a symbol: ~s." 'type-name)))
       (define Variant-name
	 (let ((expected-length (length '(Field-name ...)))
	       (field-names '(field-name ...))
	       (pred-names '(Pred? ...))
	       (preds (list (lambda (x) (Pred? x)) ...)))
	   (lambda args
	     (if (not (= (length args) expected-length))
	       (error 'Variant-name
		 (string-append
		   "Expected ~s arguments but got ~s arguments."
		   "~n  Fields are: ~s ~n  Args are: ~s.")
		 expected-length (length args) '(Field-name ...) args))
	     (for-each
	       (lambda (a f p pname)
		 (if (not (p a))
		   (error 'Variant-name "~n Bad ~a field (~s ~s) => #f."
		     f pname a)))
	       args
	       field-names
	       preds
	       pred-names)
	     (cons 'Variant-name args))))
       ...)]))
 
(define-syntax cases
  (syntax-rules ()
    [(_ Type-name Expression . Clauses)
     (let ((type-predicate? (isa Type-name)))
       (define-datatype:case-checker
	 Type-name
	 'Type-name
	 'Expression
	 'Clauses)
       (let ([x Expression])
	 (if (type-predicate? x)
	   (define-datatype:case-helper x . Clauses)
	   (begin
	     (pretty-print
	       (cons 'cases
		 (cons 'Type-name
		   (cons 'Expression 'Clauses))))
	     (error 'cases
	       "~n  Not a ~a variant: ~s." 'Type-name x)))))]))

;;; this only works because no-variant datatypes are invalid.
(define-syntax define-datatype:case-helper
  (syntax-rules (else)
    [(_ Variant [else Body0 Body1 ...])
     (begin Body0 Body1 ...)]
    [(_ Variant [Purported-variant-name (Purported-field-name ...)
		  Body0 Body1 ...])
     (apply (lambda (Purported-field-name ...) Body0 Body1 ...)
       (cdr Variant))]
    [(_ Variant [Purported-variant-name (Purported-field-name ...)
		  Body0 Body1 ...]
       Clause ...)
     (if (eq? (car Variant) 'Purported-variant-name)
	 (apply (lambda (Purported-field-name ...) Body0 Body1 ...)
	   (cdr Variant))
	 (define-datatype:case-helper Variant Clause ...))]))

;;; ------------------------------
;;; general helpers

(define always?
  (lambda (x) #t))

(define list-of
  (lambda (pred . l)
    (let ((all-preds (cons pred l)))
      (lambda (obj)
        (let loop ((obj obj) (preds '()))
          (or 
            ;; if list is empty, preds should be, too
            (and (null? obj) (null? preds))
            (if (null? preds)
		;; if preds is empty, but list isn't, then recycle
		(loop obj all-preds)
		;; otherwise check and element and recur.
		(and (pair? obj)
		     ((car preds) (car obj))
		     (loop (cdr obj) (cdr preds))))))))))

;;; ------------------------------
;;; examples

;;; (test-c) to test the entire suite of tests for Chez
;;; (test-m) to test the entire suite of tests for mzscheme.
;;; (test-all) should be set up here

(define test-all #f)
(if (chez?)
    (set! test-all (lambda () (test-c)))
    (set! test-all (lambda () (test-m))))

;;; ----------------------------------------

(define-datatype btree btree?
  (empty-btree)
  (btree-node (left btree?) (key integer?) (right btree?)))

(define sort-intlist
  (letrec ((flatten-btree
	     (lambda (bt acc)
	       (cases btree bt
		 (empty-btree () acc)
		 (btree-node (left key right)
		   (flatten-btree left
		     (cons key
		       (flatten-btree right acc)))))))
	   (insert-list
	     (lambda (ls bt)
	       (if (null? ls) bt
		   (insert-list (cdr ls) (insert (car ls) bt)))))
	   (insert
	     (lambda (n bt)
	       (cases btree bt
		 (empty-btree ()
		   (btree-node (empty-btree) n (empty-btree)))
		 (btree-node (left key right)
		   (cond
		     ((equal? n key) bt)
		     ((< n key)
		      (btree-node (insert n left) key right))
		     (else
		       (btree-node left key (insert n right)))))))))
    (lambda (ls)
      (flatten-btree (insert-list ls (empty-btree)) '()))))

(define test0
  '(sort-intlist '(8 6 7 5 3 0 9)))

;;; ------------------------------

(define-datatype lyst lyst?
  (nil)
  (pair (head always?) (tail lyst?)))

(define list->lyst
  (lambda (ls)
    (if (null? ls)
	(nil)
	(pair (car ls) (list->lyst (cdr ls))))))

(define lyst->list			; this tests hygiene
  (lambda (pr)
    (cases lyst pr
      (nil () '())
      (pair (head tail)
	(cons head (lyst->list tail))))))

(define test1
  '(lyst->list (list->lyst '(this is a weird form of identity))))

(define lyst-nil?			; this tests else-ability
  (lambda (pr)
    (cases lyst pr
      (nil () #t)
      (else #f))))

(define test2
  '(list (lyst-nil? (nil)) (lyst-nil? (pair 3 (nil)))))

(define test3
  '(begin
     (define-datatype alist alist?
       [anil]
       [apair [head always?] [tail blist?]])
     (define-datatype blist blist?
       [bnil]
       [bpair [head always?] [tail alist?]])
     (apair 5 (bpair 4 (anil)))))

(define test4
  '(begin
     (define-datatype fff fff?
       [wu]
       [bu (fff fff?)])
     (let ((fff 3))
       (fff? (bu (wu))))))

;;; ------------------------------
;;; error tests

(define err0				; wrong # args to a constructor
  '(pair))

(define err1				; wrong type args to a constructor
  '(pair 3 4))

(define err2				; unlisted variant in cases
  '(cases lyst (nil)
     (nil () 3)))

(define err3				; wrong type argument to case
  '(cases lyst 5
     (pair (x y) 3)
     (nil () 8)))

(define err4				; wrong # fields in cases
  '(cases lyst (nil)
     (pair (y z) 4)
     (nil (x) 3)
     (else 5)))

(define err5				; misspelled variant in cases
  '(cases lyst (nil)
     (ppair (y z) 4)
     (nil () 8)
     (else 5)))

(define err10                           ; non-symbol used for variant name
  '(define-datatype x x?
     [(r) [a b]]))

(define err11                           ; duplicate variant names
  '(define-datatype x x?
     [r [zoo goo?]]
     [r [foo goo?]]
     [s [joo goo?]]))

(define err14                           ; only type name
  '(define-datatype a a?))

(define err18				; duplicate variant clauses
  '(cases lyst (nil)
     (nil () 3)
     (nil () 4)))

(define err19                           ; repeated variant name.
  '(begin
     (define-datatype www www?
       [foo (man www?)])
     (define-datatype zzz zzz?
       [foo (harry zzz?)])))

(define err20                           ; isa's synbol arg is not a type name
  '(begin
     (define-datatype uu uu?
       [goo (man number?)])
     (pretty-print (uu? (goo 5)))
     (uuu? (goo 6))))

(define err21                           ; Too many args to uuuu?
  '(begin
     (define-datatype uuuu uuuu?
       [gu]
       [zu (foo uuuu?)])
     (uuuu? (zu (zu (gu))) 5)))

(define err22                           ; Too few args to isa
  '(begin
     (define-datatype uuuu uuuu?
       [gu]
       [zu (foo uuuu?)])
     ( (zu (zu (gu)))?)))

(define err23                           ; Too many args to isa
  '(begin
     (define-datatype uuuu uuuu?
       [gu]
       [zu (foo uuuu?)])
     (uuuu? (zu (zu (gu))))))

(define err24                           ; type name cannot be chosen
  '(begin                               ; from existing variant name
     (define-datatype uuuu uuuu?
       [gu]
       [zu (foo uuuu?)])
     (define-datatype gu gu?
       [hood])
     (uuuu? (zu (zu (gu))))))

(define err25                           ; type name and constructor name
  '(begin                               ; cannot be the same.
     (define-datatype uuuu uuuu?
       [gu]
       [uuuu (foo uuuu?)])
     (uuuu? (zu (zu (gu))))))

(define err26                           ; variantr name cannot be chosen
  '(begin                               ; from existing type name
     (define-datatype uuuu uuuu?
       [gu]
       [uuuu^ (foo uuuu?)])
     (define-datatype gru gru?
       [uuuu])
     (uuuu? (zu (zu (gu))))))

(define err27                           ; isa's arg is not a symbol.
  '(begin                               
     (define-datatype uuuu uuuu?
       [gu]
       [uuuu^ (foo uuuu?)])
     (5? (zu (zu (gu))))))

(define err28                           ; 1st & 2nd arg of cases should not
  '(begin                               ; be the same.
     (define-datatype uuuu** uuuu**?
       [gud]
       [uuuu^^ (foo uuuu**?)])
     (let ((uuuu** (uuuu^^ (uuuu^^ (gud)))))
       (cases uuuu** uuuu**
	 [gud () "Hello"]
	 [uuuu^^ (foo) "Goodbye"]))))

(define err29                           ; 2nd arg of cases should not
  '(begin                               ; be the same as any variant name.
     (define-datatype uuuu** uuuu**?
       [gud]
       [uuuu^^ (foo uuuu**?)])
     (let ((uuuu^^ (uuuu^^ (uuuu^^ (gud)))))
       (cases uuuu** uuuu^^
	 [gud () "Hello"]
	 [uuuu^^ (foo) "Goodbye"]))))

(define do-all-tests
  (let ((tests (list test0 test1 test2 test3 test4
		 err0 err1 err2 err3 err4 err5 err10 err11 err14
		 err18 err19 err20 err21 err22 err23
		 err24 err25 err26 err27 err28 err29)))
    (lambda (chezer)
      (for-each	chezer tests))))

(define chezer
  (lambda (example)
    (printf "------------------------------~n")
    (pretty-print example)
    (printf "-->~n")
    (call/cc
      (lambda (k)
	(parameterize
	  ((error-handler
	     (lambda (who what . args)
	       (printf "Error in ~a: ~a~n" who
		 (apply format what args))
	       (k))))
	  (write (eval example))
	  (newline))))))

(define test-c
  (lambda ()
    (do-all-tests chezer)
    (define-datatype:reset-registries)))

;;; -----------------------------------------> mzscheme stuff

(define mzschemer
  (lambda (example)
    (printf "------------------------------~n")
    (pretty-print example)
    (printf "-->~n")
    (with-handlers
      ([(lambda (x) #t)
	(lambda (an-exception)
	  (display "Error in ")
	  (display (exn-message an-exception)) (newline))])
      (write (eval example))
      (newline))))

(define test-m
  (lambda ()
    (do-all-tests mzschemer)
    (define-datatype:reset-registries)))


